<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <h2 id="4-12-">4.12　循环队列</h2>

  <p>线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。我们先来看队列的顺序存储结构。</p>

  <h3 id="4-12-1-">4.12.1　队列顺序存储的不足</h3>

  <p>我们假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，并把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为O(1)，如图4-12-1所示。</p>

  <p><img alt="" src="../Images/4-12-1.jpg" /></p>

  <p>图4-12-1</p>

  <p>与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为O(n)，如图4-12-2所示。</p>

  <p><img alt="" src="../Images/4-12-2.jpg" /></p>

  <p>图4-12-2</p>

  <p>这里的实现和线性表的顺序存储结构完全相同，不再详述。</p>

  <p>在现实中也是如此，一群人在排队买票，前面的人买好了离开，后面的人就要全部向前一步，补上空位，似乎这也没什么不好。</p>

  <p>可有时想想，为什么出队列时一定要全部移动呢，如果不去限制队列的元素必须存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定在下标为0的位置，如图4-12-3所示。</p>

  <p><img alt="" src="../Images/4-12-3.jpg" /></p>

  <p>图4-12-3</p>

  <p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。</p>

  <p>假设是长度为5的数组，初始状态，空队列如图4-12-4的左图所示，front与rear指针均指向下标为0的位置。然后入队a<sub>1</sub>、a<sub>2</sub>、a<sub>3</sub>、a<sub>4</sub>，front指针依然指向下标为0位置，而rear指针指向下标为4的位置，如图4-12-4的右图所示。</p>

  <p><img alt="" src="../Images/4-12-4.jpg" /></p>

  <p>图4-12-4</p>

  <p>出队a<sub>1</sub>、a<sub>2</sub>，则front指针指向下标为2的位置，rear不变，如图4-12-5的左图所示，再入队a<sub>5</sub>，此时front指针不变，rear指针移动到数组之外。嗯？数组之外，那将是哪里？如图4-12-5的右图所示。</p>

  <p><img alt="" src="../Images/4-12-5.jpg" /></p>

  <p>图4-12-5</p>

  <p>问题还不止于此。假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做“假溢出”。</p>

  <p>现实当中，你上了公交车，发现前排有两个空座位，而后排所有座位都已经坐满，你会怎么做？立马下车，并对自己说，后面没座了，我等下一辆？</p>

  <p>没有这么笨的人，前面有座位，当然也是可以坐的，除非坐满了，才会考虑下一辆。</p>

  <h3 id="4-12-2-">4.12.2　循环队列定义</h3>

  <p>所以解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p>

  <p>刚才的例子继续，图4-12-5的rear可以改为指向下标为0的位置，这样就不会造成指针指向不明的问题了，如图4-12-6所示。</p>

  <p><img alt="" src="../Images/4-12-6.jpg" /></p>

  <p>图4-12-6</p>

  <p>接着入队a<sub>6</sub>，将它放置于下标为0处，rear指针指向下标为1处，如图4-12-7的左图所示。若再入队a<sub>7</sub>，则rear指针就与front指针重合，同时指向下标为2的位置，如图4-12-7的右图所示。</p>

  <p><img alt="" src="../Images/4-12-7.jpg" /></p>

  <p>图4-12-7</p>

  <ul>
    <li>此时问题又出来了，我们刚才说，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</li>

    <li>办法一是设置一个标志变量flag，当front==rear，且flag=0时为队列空，当front==rear，且flag=1时为队列满。</li>

    <li>办法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。例如图4-12-8所示，我们就认为此队列已经满了，也就是说，我们不允许图4-12-7的右图情况出现。</li>
  </ul>

  <p><img alt="" src="../Images/4-12-8.jpg" /></p>

  <p>图4-12-8</p>

  <p>我们重点来讨论第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front（取模“%”的目的就是为了整合rear与front大小为一个问题）。比如上面这个例子，QueueSize=5，图4-12-8的左图中front=0，而rear=4，(4+1)%5=0，所以此时队列满。再比如图4-12-8中的右图，front=2而rear=1。(1+1)%5=2，所以此时队列也是满的。而对于图4-12-6，front=2而rear=0，(0+1)%5=1，1≠2，所以此时队列并没有满。</p>

  <p>另外，当rear&gt;front时，即图4-12-4的右图和4-12-5的左图，此时队列的长度为rear-front。但当rear&lt;front时，如图4-12-6和图4-12-7的左图，队列长度分为两段，一段是QueueSize-front，另一段是0+rear，加在一起，队列长度为rear-front+QueueSize。因此通用的计算队列长度公式为：</p>
  <pre>
(rear-front+QueueSize)%QueueSize
</pre>

  <p>有了这些讲解，现在实现循环队列的代码就不难了。</p>

  <p>循环队列的顺序存储结构代码如下：</p>
  <pre>
/* QElemType类型根据实际情况而定，这里假设为int */
typedef int QElemType;    
/* 循环队列的顺序存储结构 */
typedef struct
{
    QElemType data[MAXSIZE];
    /* 头指针 */
    int front;            
    /* 尾指针，若队列不空，
       指向队列尾元素的下一个位置 */
    int rear;             
} SqQueue;
</pre>

  <p>循环队列的初始化代码如下：</p>
  <pre>
/* 初始化一个空队列Q */
Status InitQueue(SqQueue *Q)
{
    Q-&gt;front = 0;
    Q-&gt;rear = 0;
    return OK;
}
</pre>

  <p>循环队列求队列长度代码如下：</p>
  <pre>
/* 返回Q的元素个数，也就是队列的当前长度 */
int QueueLength(SqQueue Q)
{
    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}
</pre>

  <p>循环队列的入队列操作代码如下：</p>
  <pre>
/* 若队列未满，则插入元素e为Q新的队尾元素 */
Status EnQueue(SqQueue *Q, QElemType e)
{
    /* 队列满的判断 */
    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    
        return ERROR;
    /* 将元素e赋值给队尾 */
    Q-&gt;data[Q-&gt;rear] = e;                       
    /* rear指针向后移一位置， */
    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;          
    /* 若到最后则转到数组头部 */
    return OK;
}
</pre>

  <p>循环队列的出队列操作代码如下：</p>
  <pre>
/* 若队列不空，则删除Q中队头元素，用e返回其值 */
Status DeQueue(SqQueue *Q, QElemType *e)
{
    /* 队列空的判断 */
    if (Q-&gt;front == Q-&gt;rear)                
        return ERROR;
    /* 将队头元素赋值给e */
    *e = Q-&gt;data[Q-&gt;front];                 
    /* front指针向后移一位置， */
    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    
    /* 若到最后则转到数组头部 */
    return  OK;
}
</pre>

  <p>从这一段讲解，大家应该发现，单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下不需要担心队列长度的链式存储结构。</p>
</body>
</html>
