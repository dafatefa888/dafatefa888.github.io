<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <h3 id="9-8-2-">9.8.2　归并排序复杂度分析</h3>

  <p>我们来分析一下归并排序的时间复杂度，一趟归并需要将SR[1]～SR[n]中相邻的长度为h的有序序列进行两两归并。并将结果放到TR1[1]～TR1[n]中，这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行次，因此，总的时间复杂度为O(nlogn)，而且这是归并排序算法中最好、最坏、平均的时间性能。</p>

  <p>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为log</p>

  <p>2n的栈空间，因此空间复杂度为O(n+logn)。</p>

  <p>另外，对代码进行仔细研究，发现Merge函数中有if(SR[i]&lt;SR[j])语句，这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。</p>

  <p>也就是说，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p>
</body>
</html>
