<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <h3 id="6-4-2-">6.4.2　孩子表示法</h3>

  <p>换一种完全不同的考虑方法。由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p>

  <p>方案一</p>

  <p>一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大值。其结构如表6-4-5所示。</p>

  <p><img alt="" src="../Images/6-0-3.jpg" /></p>

  <p>表6-4-5</p>

  <p>其中data是数据域。child1到childd是指针域，用来指向该结点的孩子结点。</p>

  <p>对于图6-4-1的树来说，树的度是3，所以我们的指针域的个数是3，这种方法实现如图6-4-2所示。</p>

  <p><img alt="" src="../Images/6-4-2.jpg" /></p>

  <p>图6-4-2</p>

  <p>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。</p>

  <p>既然很多指针域都可能为空，为什么不按需分配空间呢。于是我们有了第二种方案。</p>

  <p>方案二</p>

  <p>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数，其结构如表6-4-6所示。</p>

  <p><img alt="" src="../Images/6-0-4.jpg" /></p>

  <p>表6-4-6</p>

  <p>其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到childd为指针域，指向该结点的各个孩子的结点。</p>

  <p>对于图6-4-2的树来说，这种方法实现如图6-4-3所示。</p>

  <p><img alt="" src="../Images/6-4-3.jpg" /></p>

  <p>图6-4-3</p>

  <p>这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p>

  <p>能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同。</p>

  <p>仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。</p>

  <p>这就是我们要讲的孩子表示法。具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中，如图6-4-4所示。</p>

  <p><img alt="" src="../Images/6-4-4.jpg" /></p>

  <p>图6-4-4</p>

  <p>为此，设计两种结点结构，一个是孩子链表的孩子结点，如表6-4-7所示。</p>

  <p>表6-4-7</p>

  <table>
    <thead>
      <tr>
        <td></td>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td>child</td>

        <td>next</td>
      </tr>
    </tbody>
  </table>

  <p>其中child是数据域，用来存储某个结点在表头数组中的下标。next是指针域，用来存储指向某结点的下一个孩子结点的指针。</p>

  <p>另一个是表头数组的表头结点，如表6-4-8所示。</p>

  <p>表6-4-8</p>

  <table>
    <thead>
      <tr>
        <td></td>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td>data</td>

        <td>firstchild</td>
      </tr>
    </tbody>
  </table>

  <p>其中data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点的孩子链表的头指针。</p>

  <p>以下是我们的孩子表示法的结构定义代码。</p>
  <pre>
/* 树的孩子表示法结构定义 */
#define MAX_TREE_SIZE 100
/* 孩子结点 */
typedef struct CTNode              
{
    int child;
    struct CTNode *next;
} *ChildPtr;
/* 表头结构 */
typedef struct                     
{
    TElemType data;
    ChildPtr firstchild;
} CTBox;
/* 树结构 */
typedef struct                     
{
    /* 结点数组 */
    CTBox nodes[MAX_TREE_SIZE];    
    /* 根的位置和结点数 */
    int r,n;                       
} CTree;
</pre>

  <p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p>

  <p>但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。如图6-4-5所示。</p>

  <p><img alt="" src="../Images/6-4-5.jpg" /></p>

  <p>图6-4-5</p>

  <p>我们把这种方法称为双亲孩子表示法，应该算是孩子表示法的改进。至于这个表示法的具体结构定义，这里就略过，留给同学们自己去设计了。</p>
</body>
</html>
