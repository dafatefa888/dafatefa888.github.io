<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <h2 id="2-13-">2.13　总结回顾</h2>

  <p>不容易，终于又到了总结的时间。</p>

  <p>我们这一章主要谈了算法的一些基本概念。谈到了数据结构与算法的关系是相互依赖不可分割的。</p>

  <p>算法的定义：算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。</p>

  <p>算法的特性：有穷性、确定性、可行性、输入、输出。</p>

  <p>算法的设计的要求：正确性、可读性、健壮性、高效率和低存储量需求。</p>

  <p>算法特性与算法设计容易混，需要对比记忆。</p>

  <p>算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法。</p>

  <p>在讲解如何用事前分析估算方法之前，我们先给出了函数渐近增长的定义。</p>

  <p>函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着n的变大，它会越来越优于另一算法，或者越来越差于另一算法。</p>

  <p>然后给出了算法时间复杂度的定义和推导大O阶的步骤。</p>

  <p>推导大O阶：</p>

  <ul>
    <li>用常数1取代运行时间中的所有加法常数。</li>

    <li>在修改后的运行次数函数中，只保留最高阶项。</li>

    <li>如果最高阶项存在且不是1，则去除与这个项相乘的常数。</li>
  </ul>

  <p>得到的结果就是大O阶。</p>

  <p>通过这个步骤，我们可以在得到算法的运行次数表达式后，很快得到它的时间复杂度，即大O阶。同时我也提醒了大家，其实推导大O阶很容易，但如何得到运行次数的表达式却是需要数学功底的。</p>

  <p>接着我们给出了常见的时间复杂度所耗时间的大小排列：</p>
  <pre>
O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n<sup>2</sup>)&lt;O(n<sup>3</sup>)&lt;O(2<sup>n</sup>)&lt;O(n!)&lt;O(n<sup>n</sup>)
</pre>

  <p>最后，我们给出了关于算法最坏情况和平均情况的概念，以及空间复杂度的概念。</p>
</body>
</html>
